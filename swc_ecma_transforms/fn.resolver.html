<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="See Ident for know how does swc manages identifiers."><title>resolver in swc_ecma_transforms - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-2c208a72533b4dd0.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="swc_ecma_transforms" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0-nightly (ccfcd950b 2024-04-15)" data-channel="nightly" data-search-js="search-ffac13a0df2b1870.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-e32f0c247825364d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-c97aec732c613ca4.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../swc_ecma_transforms/index.html">swc_ecma_transforms</a><span class="version">0.232.1</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../swc_ecma_transforms/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">swc_ecma_transforms</a>::<wbr><a class="fn" href="#">resolver</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub fn resolver(
    unresolved_mark: Mark,
    top_level_mark: Mark,
    typescript: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>
) -&gt; impl Fold + VisitMut + 'static</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>See [Ident] for know how does swc manages identifiers.</p>
<h2 id="when-to-run"><a class="doc-anchor" href="#when-to-run">§</a>When to run</h2>
<p>The resolver expects ‘clean’ ast. You can get clean ast by parsing, or by
removing all syntax context in ast nodes.</p>
<h2 id="what-does-it-do"><a class="doc-anchor" href="#what-does-it-do">§</a>What does it do</h2>
<p>Firstly all scopes (fn, block) has it’s own SyntaxContext.
Resolver visits all identifiers in module, and look for binding identifies
in the scope. Those identifiers now have the SyntaxContext of scope (fn,
block). While doing so, resolver tries to resolve normal identifiers (no
hygiene info) as a reference to identifier of scope. If the resolver find
suitable variable, the identifier reference will have same context as the
variable.</p>
<h2 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h2>
<p><code>top_level_mark</code> should not be root.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2><div class="example-wrap"><pre class="language-js"><code>let a = 1;
{
    let a = 2;
    use(a);
}
use(a)
</code></pre></div>
<p>resolver does</p>
<ol>
<li>
<p>Define <code>a</code> with top level context.</p>
</li>
<li>
<p>Found a block, so visit block with a new syntax context.</p>
</li>
<li>
<p>Defined <code>a</code> with syntax context of the block statement.</p>
</li>
<li>
<p>Found usage of <code>a</code>, and determines that it’s reference to <code>a</code> in the
block. So the reference to <code>a</code> will have same syntax context as <code>a</code> in the
block.</p>
</li>
<li>
<p>Found usage of <code>a</code> (last line), and determines that it’s a
reference to top-level <code>a</code>, and change syntax context of <code>a</code> on last line to
top-level syntax context.</p>
</li>
</ol>
<h2 id="parameters"><a class="doc-anchor" href="#parameters">§</a>Parameters</h2><h3 id="unresolved_mark"><a class="doc-anchor" href="#unresolved_mark">§</a><code>unresolved_mark</code></h3>
<p>[Mark] applied to unresolved references.</p>
<p>A pass should accept this [Mark] if it’s going to generate a refernce to
globals like <code>require</code>.</p>
<p>e.g. <code>common_js</code> pass generates calls to <code>require</code>, and this should not
be shadowed by a declaration named <code>require</code> in the same file.
So it uses this value.</p>
<h3 id="top_level_mark"><a class="doc-anchor" href="#top_level_mark">§</a><code>top_level_mark</code></h3>
<p>[Mark] applied to top-level bindings.</p>
<p><strong>NOTE</strong>: This is <strong>not</strong> globals. This is for top level items declared by
users.</p>
<p>A pass should accept this [Mark] if it requires user-defined top-level
items.</p>
<p>e.g. <code>jsx</code> pass requires to call <code>React</code> imported by the user.</p>
<div class="example-wrap"><pre class="language-js"><code>import React from &#39;react&#39;;
</code></pre></div>
<p>In the code above, <code>React</code> has this [Mark]. <code>jsx</code> passes need to
reference this [Mark], so it accpets this.</p>
<p>This [Mark] should be used for referencing top-level bindings written by
user. If you are going to create a binding, use <code>private_ident</code>
instead.</p>
<p>In other words, <strong>this [Mark] should not be used for determining if a
variable is top-level.</strong> This is simply a configuration of the <code>resolver</code>
pass.</p>
<h3 id="typescript"><a class="doc-anchor" href="#typescript">§</a><code>typescript</code></h3>
<p>Enable this only if you are going to strip types or apply type-aware
passes like decorators pass.</p>
<h2 id="faq"><a class="doc-anchor" href="#faq">§</a>FAQ</h2><h3 id="does-a-pair-jsword-syntaxcontext-always-uniquely-identifiers-a"><a class="doc-anchor" href="#does-a-pair-jsword-syntaxcontext-always-uniquely-identifiers-a">§</a>Does a pair <code>(JsWord, SyntaxContext)</code> always uniquely identifiers a</h3>
<p>variable binding?</p>
<p>Yes, but multiple variables can have the exactly same name.</p>
<p>In the code below,</p>
<div class="example-wrap"><pre class="language-js"><code>var a = 1, a = 2;
</code></pre></div>
<p>both of them have the same name, so the <code>(JsWord, SyntaxContext)</code> pair will
be also identical.</p>
</div></details></section></div></main></body></html>